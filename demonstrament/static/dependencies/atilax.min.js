const e={string:String,number:Number,boolean:Boolean,bigint:BigInt,undefined:void 0,null:null},t=(Object.keys(e),Object.values(e),{object:Object,array:Array}),r=(Object.keys(t),Object.values(t),Object.assign({},e,t));Object.keys(r),Object.values(r),e.String,e.Number,e.Boolean;var n=e=>Object.prototype.toString.call(e).slice(8,-1).toLowerCase();function o(e){let t;const r=n(e);if("string"===r){const r=e.toLowerCase();"object"===r?t={}:"array"===r&&(t=[])}else"object"===r?t={}:"array"===r&&(t=[]);return t}function s(e,...t){if(!e)return e;for(const r of t)if(r)for(const[t,o]of Object.entries(r)){const r=n(e[t]),c=n(o);e[t]="object"===r&&"object"===c?s(e[t],o):o}return e}var c={ancestors:[],delimiter:".",depth:0,frozen:!1,maxDepth:10,nonenumerable:!0,path:!1,sealed:!1,type:!1};function i(e,t,r){const o=Object.assign({},c,r,{ancestors:Object.assign([],r.ancestors)}),s=Object.getOwnPropertyDescriptor(e,t);if((o.nonenumerable||s.enumerable)&&(o.ancestors.includes(e)||o.ancestors.unshift(e),!o.ancestors.includes(s.value)))return o.path&&(o.path="string"===n(o.path)?[o.path,t].join(o.delimiter):t,s.path=o.path),o.type&&(s.type=n(s.value)),o.frozen&&(s.frozen=Object.isFrozen(s.value)),o.sealed&&(s.sealed=Object.isSealed(s.value)),["array","object"].includes(n(s.value))&&(s.value=a(s.value,o)),s}function a(e,t){const r={},n=Object.assign({},c,t);if(n.depth>=n.maxDepth)return r;n.depth++;for(const[t,o]of Object.entries(Object.getOwnPropertyDescriptors(e))){const o=i(e,t,n);void 0!==o&&(r[t]=o)}return r}var u={typeCoercion:!1};function l(t,r,s,c){const i=Object.assign({},s),a=Object.assign({},u,c),l=n(i.value);if(["array","object"].includes(l)){const e=(e=>{let t;const r=n(e);if("array"===r)t=!0;else if("object"===r&&Number.isInteger(e.length)&&e.length>=0){e:for(const r of Object.keys(Object.getOwnPropertyDescriptors(e)))if("length"!==r&&(t=!isNaN(r),!t))break e}else t=!1;return t})(Object.defineProperties(o(l),i.value))?[]:{};i.value=f(e,i.value,a)}else a.typeCoercion&&void 0!==Object.getOwnPropertyDescriptor(i,"type")&&!["undefined","null"].includes(l)&&(i.value=e[i.type](i.value));return Object.defineProperty(t,r,i),s.sealed&&Object.seal(t[r]),s.frozen&&Object.freeze(t[r]),t}function f(e,t,r){const n=Object.assign({},u,r);for(const[r,o]of Object.entries(t))l(e,r,o,n);return e}var p=e=>s({basename:"",propertyDescriptors:!1,defineProperties:{typeCoercion:!0},replacers:[function(e,t){return"bigint"===n(t)?String(t):t}],revivers:[function(e,t){return t}]},e);function b(e,t,r){let n=r;for(const o of e)n=o(t,r);return n}class v extends EventTarget{constructor(e,t){if(super(),!e)return null;const r=p(t),n=localStorage;Object.defineProperties(this,{path:{value:e},raw:{value:function(){return n.getItem(this.path)}},get:{value:function(){let e=n.getItem(this.path);if(["undefined",void 0].includes(e))return;const t=JSON.parse(e,b.bind(null,r.revivers));if(e){const n=o(t);e=r.propertyDescriptors?f(n,t,r.defineProperties):t}return e}},set:{value:function(e){return r.propertyDescriptors?n.setItem(this.path,JSON.stringify(a(e,r.propertyDescriptors),b.bind(null,r.replacers))):n.setItem(this.path,JSON.stringify(e,b.bind(null,r.replacers)))}},remove:{value:function(){return n.removeItem(this.path)}}})}}const d={};class j extends EventTarget{constructor(e={},t){super();Object.assign({},d,t);const r={},n=localStorage;Object.defineProperties(this,{addRoute:{value:function(e,t){r[e]=new v(e,t)}},addRoutes:{value:function(e,t){for(const[t,r]of Object.entries(e))this.addRoute(t,r)}},removeRoute:{value:function(e){delete r[e]}},removeRoutes:{value:function(e){for(const t of e)this.removeRoute(t)}},getRoute:{value:function(e){return r[e]}},getRoutes:{value:function(e){if(!e)return r;const t={};for(const r of[].concat(e))t[r]=this.getRoute(r);return t}},clear:{value:function(){n.clear()}}}),this.addRoutes(e)}}export{v as Route,j as Router};
//# sourceMappingURL=atilax.min.js.map
