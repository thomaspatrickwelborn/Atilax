{"version":3,"file":"atilax.js","sources":["../../../../Recourse/distributement/recourse.js","../../../development/route/options.js","../../../development/route/index.js","../../../development/router/index.js"],"sourcesContent":["const Primitives = {\n  'string': String, \n  'number': Number, \n  'boolean': Boolean, \n  'bigint': BigInt,\n  'undefined': undefined,\n  'null': null,\n};\nconst PrimitiveKeys = Object.keys(Primitives);\nconst PrimitiveValues = Object.values(Primitives);\nconst Objects = {\n  'object': Object,\n  'array': Array,\n};\nconst ObjectKeys = Object.keys(Objects);\nconst ObjectValues = Object.values(Objects);\nconst Types = Object.assign({}, Primitives, Objects);\nconst TypeKeys = Object.keys(Types);\nconst TypeValues = Object.values(Types);\nconst TypeMethods = [\n Primitives.String, Primitives.Number, Primitives.Boolean, \n Objects.Object, Objects.Array\n];\n\nvar index = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ObjectKeys: ObjectKeys,\n  ObjectValues: ObjectValues,\n  Objects: Objects,\n  PrimitiveKeys: PrimitiveKeys,\n  PrimitiveValues: PrimitiveValues,\n  Primitives: Primitives,\n  TypeKeys: TypeKeys,\n  TypeMethods: TypeMethods,\n  TypeValues: TypeValues,\n  Types: Types\n});\n\nvar typeOf = ($data) => Object\n  .prototype\n  .toString\n  .call($data).slice(8, -1).toLowerCase();\n\nfunction typedObjectLiteral($value) {\n  let _typedObjectLiteral;\n  const typeOfValue = typeOf($value);\n  if(typeOfValue === 'string') {\n    const value = $value.toLowerCase();\n    if(value === 'object') { _typedObjectLiteral = {}; }\n    else if(value === 'array') { _typedObjectLiteral = []; }\n  }\n  else  {\n    if(typeOfValue === 'object') { _typedObjectLiteral = {}; }\n    else if(typeOfValue === 'array') { _typedObjectLiteral = []; }\n  }\n  return _typedObjectLiteral\n}\n\nvar regularExpressions = {\n  quotationEscape: /\\.(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/,\n};\n\nfunction get($path, $source) {\n  const subpaths = $path.split(new RegExp(regularExpressions.quotationEscape));\n  const key = subpaths.pop();\n  let subtarget = $source;\n  for(const $subpath of subpaths) { subtarget = subtarget[$subpath]; }\n  return subtarget[key]\n}\nfunction set($path, $source) {\n  const subpaths = $path.split(new RegExp(regularExpressions.quotationEscape));\n  const key = subpaths.pop();\n  const target = (key && !isNaN(key)) ? [] : {};\n  let subtarget = target;\n  let subpathIndex = 0;\n  while(subpathIndex < subpaths.length - 2) {\n    const $subpath = keypaths[subpathIndex];\n    if(isNaN($subpath)) { subtarget[$subpath] = {}; }\n    else { subtarget[$subpath] = {}; }\n    subtarget = subtarget[$subpath];\n    subpathIndex++;\n  }\n  subtarget[key] = $source;\n  return target\n}\n\nconst ValidPropertyTypes = ['string', 'function'];\nfunction expandTree($source, $property) {\n  const typeOfProperty = typeOf($property);\n  const typeOfSource = typeOf($source);\n  if(\n    !ValidPropertyTypes.includes(typeOfProperty) ||\n    !ObjectKeys.includes(typeOfSource)\n  ) { return $source }\n  let target = typedObjectLiteral($source);\n  for(const [$sourceKey, $sourceValue] of Object.entries($source)) {\n    const sourceValue = (\n      ObjectKeys.includes(typeOf($sourceValue))\n    ) ? expandTree($sourceValue, $property) : $sourceValue;\n    if(typeOfProperty === ValidPropertyTypes[0]) {\n      target[$sourceKey] = set($property, sourceValue);\n    }\n    else if(typeOfProperty === ValidPropertyTypes[1]) {\n      target[$sourceKey] = $property(sourceValue);\n    }\n  }\n  return target\n}\n\nfunction impandTree($source, $property) {\n  const typeOfProperty = typeOf($property);\n  const typeOfSource = typeOf($source);\n  if(\n    !['string', 'function'].includes(typeOfProperty) ||\n    !['array', 'object'].includes(typeOfSource)\n  ) { return $source }\n  let target = typedObjectLiteral($source);\n  for(const [$sourceKey, $sourceValue] of Object.entries($source)) {\n    if(typeOfProperty === 'string') { target[$sourceKey] = get($property, $sourceValue); }\n    else if(typeOfProperty === 'function') { target[$sourceKey] = $property($sourceValue); }\n    if(target[$sourceKey] && typeof target[$sourceKey] === 'object') {\n      target[$sourceKey] = impandTree(target[$sourceKey], $property);\n    }\n  }\n  return target\n}\n\nvar isArrayLike = ($source) => {\n  let isArrayLike;\n  const typeOfSource = typeOf($source);\n  if(typeOfSource === 'array') { isArrayLike = true; }\n  else if(\n    typeOfSource === 'object' &&\n    Number.isInteger($source.length) && $source.length >= 0\n  ) {\n    iterateSourceKeys: \n    for(const $sourceKey of Object.keys(\n      Object.getOwnPropertyDescriptors($source)\n    )) {\n      if($sourceKey === 'length') { continue iterateSourceKeys }\n      isArrayLike = !isNaN($sourceKey);\n      if(!isArrayLike) { break iterateSourceKeys }\n    }\n  }\n  else { isArrayLike = false; }\n  return isArrayLike\n};\n\nconst defaultAccessor = ($target, $property) => {\n  if($property === undefined) { return $target }\n  else { return $target[$property] }\n};\nvar Accessors = {\n  default: defaultAccessor};\n\nconst Options$2 = {\n  depth: 0,\n  maxDepth: 10,\n  accessors: [Accessors.default],\n  ancestors: [],\n};\nfunction propertyDirectory($object, $options) {\n  const _propertyDirectory = [];\n  const options = Object.assign({}, Options$2, $options, {\n    ancestors: [].concat($options.ancestors)\n  });\n  options.depth++;\n  if(options.depth > options.maxDepth) { return _propertyDirectory }\n  iterateAccessors: \n  for(const $accessor of options.accessors) {\n    const accessor = $accessor.bind($object);\n    const object = accessor($object);\n    if(!object) { continue iterateAccessors }\n    if(!options.ancestors.includes(object)) { options.ancestors.unshift(object); }\n    for(const [$key, $value] of Object.entries(object)) {\n      if(!options.values) { _propertyDirectory.push($key); }\n      else if(options.values) { _propertyDirectory.push([$key, $value]); }\n      if(\n        typeof $value === 'object' &&\n        $value !== null &&\n        !Object.is($value, object) && \n        !options.ancestors.includes($value)\n      ) {\n        const subtargets = propertyDirectory($value, options);\n        if(!options.values) {\n          for(const $subtarget of subtargets) {\n            const path = [$key, $subtarget].join('.');\n            _propertyDirectory.push(path);\n          }\n        }\n        else if(options.values) {\n          for(const [$subtargetKey, $subtarget] of subtargets) {\n            const path = [$key, $subtargetKey].join('.');\n            _propertyDirectory.push([path, $subtarget]);\n          }\n        }\n      }\n    }\n  }\n  return _propertyDirectory\n}\n\nfunction assign($target, ...$sources) {\n  if(!$target) { return $target}\n  iterateSources: \n  for(const $source of $sources) {\n    if(!$source) continue iterateSources\n    for(const [\n      $sourcePropertyKey, $sourcePropertyValue\n    ] of Object.entries($source)) {\n      const typeOfTargetPropertyValue = typeOf($target[$sourcePropertyKey]);\n      const typeOfSourcePropertyValue = typeOf($sourcePropertyValue);\n      if(\n        typeOfTargetPropertyValue === 'object' &&\n        typeOfSourcePropertyValue === 'object'\n      ) {\n        $target[$sourcePropertyKey] = assign($target[$sourcePropertyKey], $sourcePropertyValue);\n      }\n      else {\n        $target[$sourcePropertyKey] = $sourcePropertyValue;\n      }\n    }\n  }\n  return $target\n}\n\nfunction assignConcat($target, ...$sources) {\n  if(!$target) { return $target}\n  iterateSources: \n  for(const $source of $sources) {\n    if(!$source) continue iterateSources\n    for(const [\n      $sourcePropertyKey, $sourcePropertyValue\n    ] of Object.entries($source)) {\n      const typeOfTargetPropertyValue = typeOf($target[$sourcePropertyKey]);\n      const typeOfSourcePropertyValue = typeOf($sourcePropertyValue);\n      if( \n        typeOfTargetPropertyValue === 'object' &&\n        typeOfSourcePropertyValue === 'object'\n      ) {\n        $target[$sourcePropertyKey] = assignConcat($target[$sourcePropertyKey], $sourcePropertyValue);\n      }\n      else if(\n        typeOfTargetPropertyValue === 'array' &&\n        typeOfSourcePropertyValue === 'array'\n      ) {\n        $target[$sourcePropertyKey] = $target[$sourcePropertyKey].concat($sourcePropertyValue);\n      }\n      else {\n        $target[$sourcePropertyKey] = $sourcePropertyValue;\n      }\n    }\n  }\n  return $target\n}\n\nvar Options$1 = {\n  ancestors: [],\n  delimiter: '.',\n  depth: 0,\n  frozen: false,\n  maxDepth: 10,\n  nonenumerable: true,\n  path: false,\n  sealed: false,\n  type: false,\n};\n\nfunction getOwnPropertyDescriptor($properties, $propertyKey, $options) {\n  const options = Object.assign({}, Options$1, $options, {\n    ancestors: Object.assign([], $options.ancestors)\n  });\n  const propertyDescriptor = Object.getOwnPropertyDescriptor($properties, $propertyKey);\n  if(!options.nonenumerable && !propertyDescriptor.enumerable) { return }\n  if(!options.ancestors.includes($properties)) { options.ancestors.unshift($properties); }\n  if(options.ancestors.includes(propertyDescriptor.value)) { return }\n  if(options.path) {\n    options.path = (typeOf(options.path) === 'string') ? [options.path, $propertyKey].join(options.delimiter) : $propertyKey;\n    propertyDescriptor.path = options.path;\n  }\n  if(options.type) { propertyDescriptor.type = typeOf(propertyDescriptor.value); }\n  if(options.frozen) { propertyDescriptor.frozen = Object.isFrozen(propertyDescriptor.value); }\n  if(options.sealed) { propertyDescriptor.sealed = Object.isSealed(propertyDescriptor.value); }\n  if(['array', 'object'].includes(typeOf(propertyDescriptor.value))) {\n    propertyDescriptor.value = getOwnPropertyDescriptors(propertyDescriptor.value, options);\n  }\n  return propertyDescriptor\n}\n\nfunction getOwnPropertyDescriptors($properties, $options) {\n  const propertyDescriptors = {};\n  const options = Object.assign({}, Options$1, $options);\n  if(options.depth >= options.maxDepth) { return propertyDescriptors }\n  else { options.depth++; }\n  for(const [$propertyKey, $propertyDescriptor] of Object.entries(Object.getOwnPropertyDescriptors($properties))) {\n    const propertyDescriptor = getOwnPropertyDescriptor($properties, $propertyKey, options);\n    if(propertyDescriptor !== undefined) { propertyDescriptors[$propertyKey] = propertyDescriptor; }\n  }\n  return propertyDescriptors\n}\n\nvar Options = {\n  typeCoercion: false,\n};\n\nfunction defineProperty($target, $propertyKey, $propertyDescriptor, $options) {\n  const propertyDescriptor = Object.assign({}, $propertyDescriptor);\n  const options = Object.assign({}, Options, $options);\n  const typeOfPropertyValue = typeOf(propertyDescriptor.value);\n  if(['array', 'object'].includes(typeOfPropertyValue)) {\n    const propertyValue = isArrayLike(Object.defineProperties(\n      typedObjectLiteral(typeOfPropertyValue), propertyDescriptor.value\n    )) ? [] : {};\n    propertyDescriptor.value = defineProperties(propertyValue, propertyDescriptor.value, options);\n  }\n  else if(\n    options.typeCoercion && \n    Object.getOwnPropertyDescriptor(propertyDescriptor, 'type') !== undefined &&\n    !['undefined', 'null'].includes(typeOfPropertyValue)\n  ) {\n    propertyDescriptor.value = Primitives[propertyDescriptor.type](propertyDescriptor.value);\n  }\n  Object.defineProperty($target, $propertyKey, propertyDescriptor);\n  if($propertyDescriptor.sealed) { Object.seal($target[$propertyKey]); }\n  if($propertyDescriptor.frozen) { Object.freeze($target[$propertyKey]); }\n  return $target\n}\n\nfunction defineProperties($target, $propertyDescriptors, $options) {\n  const options = Object.assign({}, Options, $options);\n  for(const [\n    $propertyKey, $propertyDescriptor\n  ] of Object.entries($propertyDescriptors)) {\n    defineProperty($target, $propertyKey, $propertyDescriptor, options);\n  }\n  return $target\n}\n\nfunction freeze($target) {\n  for(const [$propertyKey, $propertyValue] of Object.entries($target)) {\n    if(Object.is($propertyValue, $target)) { continue }\n    if($propertyValue && typeof $propertyValue === 'object') {\n      freeze($propertyValue);\n    }\n  }\n  return Object.freeze($target)\n}\n\nexport { assign, assignConcat, defineProperties, defineProperty, expandTree, freeze, getOwnPropertyDescriptor, getOwnPropertyDescriptors, impandTree, isArrayLike, propertyDirectory, regularExpressions, typeOf, typedObjectLiteral, index as variables };\n//# sourceMappingURL=recourse.js.map\n","import { assign, typeOf } from 'recourse'\nexport default ($options) => {\n  const options = assign({\n    basename: '',\n    propertyDescriptors: false,\n    defineProperties: false,\n    replacers: [],\n    revivers: [],\n  }, $options)\n  if(options.propertyDescriptors?.type) {\n    options.replacers.push(function replacer($key, $value) {\n      if(typeOf($value) === 'bigint') { return String($value) }\n      else { return $value }\n    })\n  }\n  return options\n}","import {\n  defineProperties, getOwnPropertyDescriptors, typedObjectLiteral,\n} from 'recourse'\nimport Options from './options.js'\nfunction JSONMiddlewares($middlewares, $key, $value) {\n  let value = $value\n  for(const $middleware of $middlewares) {\n    value = $middleware($key, $value)\n  }\n  return value\n}\nexport default class LocalStorageRoute extends EventTarget {\n  constructor($path, $options) {\n    super()\n    if(!$path) return null\n    const options = Options($options)\n    const db = localStorage\n    Object.defineProperties(this, {\n      'path': { value: $path },\n      'raw': { value: function raw() { return db.getItem(this.path) } },\n      'get': { value: function get() {\n        let model = db.getItem(this.path)\n        if(['undefined', undefined].includes(model)) { return }\n        const modelParsement = JSON.parse(model, JSONMiddlewares.bind(null, options.revivers))\n        if(model) {\n          const modelTypedObjectLiteral = typedObjectLiteral(modelParsement)\n          if(options.propertyDescriptors) {\n            model = defineProperties(modelTypedObjectLiteral, modelParsement, options.defineProperties)\n          }\n          else {\n            model = modelParsement\n          }\n        }\n        return model\n      } },\n      'set': { value: function set($data) {\n        if(options.propertyDescriptors) {\n          return db.setItem(this.path, JSON.stringify(\n            getOwnPropertyDescriptors($data, options.propertyDescriptors), JSONMiddlewares.bind(null, options.replacers)\n          ))\n        }\n        else {\n          return db.setItem(this.path, JSON.stringify($data, JSONMiddlewares.bind(null, options.replacers)))\n        }\n      } },\n      'remove': { value: function remove() { return db.removeItem(this.path) } },\n    })\n  }\n}","import Route from '../route/index.js'\nconst Options = {}\nexport default class LocalStorageRouter extends EventTarget {\n  constructor($routes = {}, $options) {\n    super()\n    const options = Object.assign({}, Options, $options)\n    const routes = {}\n    const db = localStorage\n    Object.defineProperties(this, {\n      'addRoute': { value: function addRoute($routePath, $routeOptions) {\n        routes[$routePath] = new Route($routePath, $routeOptions)\n      } },\n      'addRoutes': { value: function addRoutes($routes, $options) {\n        for(const [$routePath, $routeOptions] of Object.entries($routes)) {\n          this.addRoute($routePath, $routeOptions)\n        }\n      } },\n      'removeRoute': { value: function removeRoute($routePath) {\n        delete routes[$routePath]\n      } }, \n      'removeRoutes': { value: function removeRoutes($routes) {\n        for(const $routePath of $routes) {\n          this.removeRoute($routePath)\n        }\n      } },\n      'getRoute': { value: function getRoute($path) {\n        return routes[$path]\n      } },\n      'getRoutes': { value: function getRoutes($paths) {\n        if(!$paths) { return routes }\n        const getRoutes = {}\n        for(const $path of [].concat($paths)) {\n          getRoutes[$path] = this.getRoute($path)\n        }\n        return getRoutes\n      } },\n      'clear': { value: function clear() { db.clear() } },\n    })\n    this.addRoutes($routes)\n  }\n}"],"names":["Options$1","Options","Route"],"mappings":"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"}