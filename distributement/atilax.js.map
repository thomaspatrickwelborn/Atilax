{"version":3,"file":"atilax.js","sources":["../node_modules/recourse/distributement/recourse.js","../development/route/options.js","../development/route/index.js","../development/router/index.js"],"sourcesContent":["const Primitives = {\n  'string': String, \n  'number': Number, \n  'boolean': Boolean, \n  'bigint': BigInt,\n  'undefined': undefined,\n  'null': null,\n};\nconst PrimitiveKeys = Object.keys(Primitives);\nconst PrimitiveValues = Object.values(Primitives);\nconst Objects = {\n  'object': Object,\n  'array': Array,\n};\nconst ObjectKeys = Object.keys(Objects);\nconst ObjectValues = Object.values(Objects);\nconst Types = Object.assign({}, Primitives, Objects);\nconst TypeKeys = Object.keys(Types);\nconst TypeValues = Object.values(Types);\nconst TypeMethods = [\n Primitives.String, Primitives.Number, Primitives.Boolean, \n Objects.Object, Objects.Array\n];\n\nvar index = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ObjectKeys: ObjectKeys,\n  ObjectValues: ObjectValues,\n  Objects: Objects,\n  PrimitiveKeys: PrimitiveKeys,\n  PrimitiveValues: PrimitiveValues,\n  Primitives: Primitives,\n  TypeKeys: TypeKeys,\n  TypeMethods: TypeMethods,\n  TypeValues: TypeValues,\n  Types: Types\n});\n\nvar typeOf = ($data) => Object\n  .prototype\n  .toString\n  .call($data).slice(8, -1).toLowerCase();\n\nfunction typedObjectLiteral($value) {\n  let _typedObjectLiteral;\n  const typeOfValue = typeOf($value);\n  if(typeOfValue === 'string') {\n    const value = $value.toLowerCase();\n    if(value === 'object') { _typedObjectLiteral = {}; }\n    else if(value === 'array') { _typedObjectLiteral = []; }\n  }\n  else  {\n    if(typeOfValue === 'object') { _typedObjectLiteral = {}; }\n    else if(typeOfValue === 'array') { _typedObjectLiteral = []; }\n  }\n  return _typedObjectLiteral\n}\n\nvar regularExpressions = {\n  quotationEscape: /\\.(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/,\n};\n\nfunction get($path, $source) {\n  const subpaths = $path.split(new RegExp(regularExpressions.quotationEscape));\n  const key = subpaths.pop();\n  let subtarget = $source;\n  for(const $subpath of subpaths) { subtarget = subtarget[$subpath]; }\n  return subtarget[key]\n}\nfunction set($path, $source) {\n  const subpaths = $path.split(new RegExp(regularExpressions.quotationEscape));\n  const key = subpaths.pop();\n  const target = (key && !isNaN(key)) ? [] : {};\n  let subtarget = target;\n  let subpathIndex = 0;\n  while(subpathIndex < subpaths.length - 2) {\n    const $subpath = keypaths[subpathIndex];\n    if(isNaN($subpath)) { subtarget[$subpath] = {}; }\n    else { subtarget[$subpath] = {}; }\n    subtarget = subtarget[$subpath];\n    subpathIndex++;\n  }\n  subtarget[key] = $source;\n  return target\n}\n\nconst ValidPropertyTypes = ['string', 'function'];\nfunction expandTree($source, $property) {\n  const typeOfProperty = typeOf($property);\n  const typeOfSource = typeOf($source);\n  if(\n    !ValidPropertyTypes.includes(typeOfProperty) ||\n    !ObjectKeys.includes(typeOfSource)\n  ) { return $source }\n  let target = typedObjectLiteral($source);\n  for(const [$sourceKey, $sourceValue] of Object.entries($source)) {\n    const sourceValue = (\n      ObjectKeys.includes(typeOf($sourceValue))\n    ) ? expandTree($sourceValue, $property) : $sourceValue;\n    if(typeOfProperty === ValidPropertyTypes[0]) {\n      target[$sourceKey] = set($property, sourceValue);\n    }\n    else if(typeOfProperty === ValidPropertyTypes[1]) {\n      target[$sourceKey] = $property(sourceValue);\n    }\n  }\n  return target\n}\n\nfunction impandTree($source, $property) {\n  const typeOfProperty = typeOf($property);\n  const typeOfSource = typeOf($source);\n  if(\n    !['string', 'function'].includes(typeOfProperty) ||\n    !['array', 'object'].includes(typeOfSource)\n  ) { return $source }\n  let target = typedObjectLiteral($source);\n  for(const [$sourceKey, $sourceValue] of Object.entries($source)) {\n    if(typeOfProperty === 'string') { target[$sourceKey] = get($property, $sourceValue); }\n    else if(typeOfProperty === 'function') { target[$sourceKey] = $property($sourceValue); }\n    if(target[$sourceKey] && typeof target[$sourceKey] === 'object') {\n      target[$sourceKey] = impandTree(target[$sourceKey], $property);\n    }\n  }\n  return target\n}\n\nvar isArrayLike = ($source) => {\n  let isArrayLike;\n  const typeOfSource = typeOf($source);\n  if(typeOfSource === 'array') { isArrayLike = true; }\n  else if(\n    typeOfSource === 'object' &&\n    Number.isInteger($source.length) && $source.length >= 0\n  ) {\n    iterateSourceKeys: \n    for(const $sourceKey of Object.keys(\n      Object.getOwnPropertyDescriptors($source)\n    )) {\n      if($sourceKey === 'length') { continue iterateSourceKeys }\n      isArrayLike = !isNaN($sourceKey);\n      if(!isArrayLike) { break iterateSourceKeys }\n    }\n  }\n  else { isArrayLike = false; }\n  return isArrayLike\n};\n\nconst defaultAccessor = ($target, $property) => {\n  if($property === undefined) { return $target }\n  else { return $target[$property] }\n};\nvar Accessors = {\n  default: defaultAccessor};\n\nconst Options$2 = {\n  depth: 0,\n  maxDepth: 10,\n  accessors: [Accessors.default],\n  ancestors: [],\n};\nfunction propertyDirectory($object, $options) {\n  const _propertyDirectory = [];\n  const options = Object.assign({}, Options$2, $options, {\n    ancestors: [].concat($options.ancestors)\n  });\n  options.depth++;\n  if(options.depth > options.maxDepth) { return _propertyDirectory }\n  iterateAccessors: \n  for(const $accessor of options.accessors) {\n    const accessor = $accessor.bind($object);\n    const object = accessor($object);\n    if(!object) { continue iterateAccessors }\n    if(!options.ancestors.includes(object)) { options.ancestors.unshift(object); }\n    for(const [$key, $value] of Object.entries(object)) {\n      if(!options.values) { _propertyDirectory.push($key); }\n      else if(options.values) { _propertyDirectory.push([$key, $value]); }\n      if(\n        typeof $value === 'object' &&\n        $value !== null &&\n        !Object.is($value, object) && \n        !options.ancestors.includes($value)\n      ) {\n        const subtargets = propertyDirectory($value, options);\n        if(!options.values) {\n          for(const $subtarget of subtargets) {\n            const path = [$key, $subtarget].join('.');\n            _propertyDirectory.push(path);\n          }\n        }\n        else if(options.values) {\n          for(const [$subtargetKey, $subtarget] of subtargets) {\n            const path = [$key, $subtargetKey].join('.');\n            _propertyDirectory.push([path, $subtarget]);\n          }\n        }\n      }\n    }\n  }\n  return _propertyDirectory\n}\n\nfunction assign($target, ...$sources) {\n  if(!$target) { return $target}\n  iterateSources: \n  for(const $source of $sources) {\n    if(!$source) continue iterateSources\n    for(const [\n      $sourcePropertyKey, $sourcePropertyValue\n    ] of Object.entries($source)) {\n      const typeOfTargetPropertyValue = typeOf($target[$sourcePropertyKey]);\n      const typeOfSourcePropertyValue = typeOf($sourcePropertyValue);\n      if(\n        typeOfTargetPropertyValue === 'object' &&\n        typeOfSourcePropertyValue === 'object'\n      ) {\n        $target[$sourcePropertyKey] = assign($target[$sourcePropertyKey], $sourcePropertyValue);\n      }\n      else {\n        $target[$sourcePropertyKey] = $sourcePropertyValue;\n      }\n    }\n  }\n  return $target\n}\n\nfunction assignConcat($target, ...$sources) {\n  if(!$target) { return $target}\n  iterateSources: \n  for(const $source of $sources) {\n    if(!$source) continue iterateSources\n    for(const [\n      $sourcePropertyKey, $sourcePropertyValue\n    ] of Object.entries($source)) {\n      const typeOfTargetPropertyValue = typeOf($target[$sourcePropertyKey]);\n      const typeOfSourcePropertyValue = typeOf($sourcePropertyValue);\n      if( \n        typeOfTargetPropertyValue === 'object' &&\n        typeOfSourcePropertyValue === 'object'\n      ) {\n        $target[$sourcePropertyKey] = assignConcat($target[$sourcePropertyKey], $sourcePropertyValue);\n      }\n      else if(\n        typeOfTargetPropertyValue === 'array' &&\n        typeOfSourcePropertyValue === 'array'\n      ) {\n        $target[$sourcePropertyKey] = $target[$sourcePropertyKey].concat($sourcePropertyValue);\n      }\n      else {\n        $target[$sourcePropertyKey] = $sourcePropertyValue;\n      }\n    }\n  }\n  return $target\n}\n\nvar Settings = {\n  depth: 0,\n  path: null,\n  ancestors: [],\n};\n\nvar Options$1 = {\n  delimiter: '.',\n  frozen: false,\n  maxDepth: 10,\n  nonenumerable: true,\n  path: false,\n  sealed: false,\n  type: false,\n};\n\nfunction getOwnPropertyDescriptor($properties, $propertyKey, $options) {\n  const options = Object.assign({}, Settings, Options$1, $options, {\n    ancestors: Object.assign([], $options.ancestors)\n  });\n  const propertyDescriptor = Object.getOwnPropertyDescriptor($properties, $propertyKey);\n  if(!options.nonenumerable && !propertyDescriptor.enumerable) { return }\n  if(!options.ancestors.includes($properties)) { options.ancestors.unshift($properties); }\n  if(options.ancestors.includes(propertyDescriptor.value)) { return }\n  if(options.path) {\n    options.path = (typeOf(options.path) === 'string') ? [options.path, $propertyKey].join(options.delimiter) : $propertyKey;\n    propertyDescriptor.path = options.path;\n  }\n  if(options.type) { propertyDescriptor.type = typeOf(propertyDescriptor.value); }\n  if(options.frozen) { propertyDescriptor.frozen = Object.isFrozen(propertyDescriptor.value); }\n  if(options.sealed) { propertyDescriptor.sealed = Object.isSealed(propertyDescriptor.value); }\n  if(['array', 'object'].includes(typeOf(propertyDescriptor.value))) {\n    propertyDescriptor.value = getOwnPropertyDescriptors(propertyDescriptor.value, options);\n  }\n  return propertyDescriptor\n}\n\nfunction getOwnPropertyDescriptors($properties, $options) {\n  const propertyDescriptors = {};\n  const options = Object.assign({}, Settings, Options$1, $options);\n  if(options.depth >= options.maxDepth) { return propertyDescriptors }\n  else { options.depth++; }\n  for(const [$propertyKey, $propertyDescriptor] of Object.entries(Object.getOwnPropertyDescriptors($properties))) {\n    const propertyDescriptor = getOwnPropertyDescriptor($properties, $propertyKey, options);\n    if(propertyDescriptor !== undefined) { propertyDescriptors[$propertyKey] = propertyDescriptor; }\n  }\n  return propertyDescriptors\n}\n\nvar Options = {\n  typeCoercion: false,\n};\n\nfunction defineProperty($target, $propertyKey, $propertyDescriptor, $options) {\n  const propertyDescriptor = Object.assign({}, $propertyDescriptor);\n  const options = Object.assign({}, Options, $options);\n  const typeOfPropertyValue = typeOf(propertyDescriptor.value);\n  if(['array', 'object'].includes(typeOfPropertyValue)) {\n    const propertyValue = isArrayLike(Object.defineProperties(\n      typedObjectLiteral(typeOfPropertyValue), propertyDescriptor.value\n    )) ? [] : {};\n    propertyDescriptor.value = defineProperties(propertyValue, propertyDescriptor.value, options);\n  }\n  else if(\n    options.typeCoercion && \n    Object.getOwnPropertyDescriptor(propertyDescriptor, 'type') !== undefined &&\n    !['undefined', 'null'].includes(typeOfPropertyValue)\n  ) {\n    propertyDescriptor.value = Primitives[propertyDescriptor.type](propertyDescriptor.value);\n  }\n  Object.defineProperty($target, $propertyKey, propertyDescriptor);\n  if($propertyDescriptor.sealed) { Object.seal($target[$propertyKey]); }\n  if($propertyDescriptor.frozen) { Object.freeze($target[$propertyKey]); }\n  return $target\n}\n\nfunction defineProperties($target, $propertyDescriptors, $options) {\n  const options = Object.assign({}, Options, $options);\n  for(const [\n    $propertyKey, $propertyDescriptor\n  ] of Object.entries($propertyDescriptors)) {\n    defineProperty($target, $propertyKey, $propertyDescriptor, options);\n  }\n  return $target\n}\n\nfunction freeze($target) {\n  for(const [$propertyKey, $propertyValue] of Object.entries($target)) {\n    if(Object.is($propertyValue, $target)) { continue }\n    if($propertyValue && typeof $propertyValue === 'object') {\n      freeze($propertyValue);\n    }\n  }\n  return Object.freeze($target)\n}\n\nexport { assign, assignConcat, defineProperties, defineProperty, expandTree, freeze, getOwnPropertyDescriptor, getOwnPropertyDescriptors, impandTree, isArrayLike, propertyDirectory, regularExpressions, typeOf, typedObjectLiteral, index as variables };\n//# sourceMappingURL=recourse.js.map\n","export default ($options) => Object.assign({\n  basename: '',\n  delimiter: '.',\n  frozen: false,\n  maxDepth: 10,\n  nonenumerable: true,\n  path: false,\n  sealed: false,\n  type: false,\n}, $options)","import {\n  defineProperties, getOwnPropertyDescriptors, typedObjectLiteral,\n} from 'recourse'\nimport Options from './options.js'\nexport default class LocalStorageRoute extends EventTarget {\n  #options\n  #db = localStorage\n  #path\n  constructor($path, $options) {\n    super()\n    if(!$path) return\n    this.#path = $path\n    this.#options = Options($options)\n  }\n  get path() { return this.#path }\n  get() {\n    let model = this.#db.getItem(this.path)\n    if(model) {\n      const modelParsement = JSON.parse(model)\n      const modelTypedObjectLiteral = typedObjectLiteral(modelParsement)\n      model = defineProperties(modelTypedObjectLiteral, modelParsement, this.#options)\n    }\n    return model\n  }\n  set($data) { return this.#db.setItem(this.path, JSON.stringify(\n    getOwnPropertyDescriptors($data, {\n      path: true,\n      type: true,\n    })\n  )) }\n  remove() { return this.#db.removeItem(this.path) }\n}","import Route from '../route/index.js'\nexport default class LocalStorageRouter extends EventTarget {\n  #options = {}\n  #routes = {}\n  constructor($routes = {}, $options) {\n    super()\n    Object.assign(this.#options, $options)\n    this.addRoutes($routes)\n  }\n  addRoutes($routes, $options) {\n    for(const [$routePath, $routeOptions] of Object.entries($routes)) {\n      this.#routes[$routePath] = new Route($routePath, $routeOptions)\n    }\n  }\n  removeRoutes($routes) {\n    for(const $routePath of $routes) {\n      delete this.#routes[$routePath]\n    }\n  }\n  getRoutes($paths) {\n    if(!$paths) { return this.#routes }\n    const routes = {}\n    for(const $path of [].concat($paths)) {\n      routes[$path] = this.#routes[$path]\n    }\n    return routes\n  }\n  clear() { localStorage.clear() }\n}"],"names":["Options","Route"],"mappings":"AAAA,MAAM,UAAU,GAAG;AACnB,EAAE,QAAQ,EAAE,MAAM;AAClB,EAAE,QAAQ,EAAE,MAAM;AAClB,EAAE,SAAS,EAAE,OAAO;AACpB,EAAE,QAAQ,EAAE,MAAM;AAClB,EAAE,WAAW,EAAE,SAAS;AACxB,EAAE,MAAM,EAAE,IAAI;AACd,CAAC;AAEuB,MAAM,CAAC,MAAM,CAAC,UAAU;AAChD,MAAM,OAAO,GAAG;AAChB,EAAE,QAAQ,EAAE,MAAM;AAClB,EAAE,OAAO,EAAE,KAAK;AAChB,CAAC;AAEoB,MAAM,CAAC,MAAM,CAAC,OAAO;AAC1C,MAAM,KAAK,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,UAAU,EAAE,OAAO,CAAC;AAEjC,MAAM,CAAC,MAAM,CAAC,KAAK;AAClB;AACpB,CAAC,UAAU,CAAC,MAAM,EAAE,UAAU,CAAC,MAAM,EAAE,UAAU,CAAC,OAAO;AACzD,CAAC,OAAO,CAAC,MAAM,EAAE,OAAO,CAAC;AACzB;;AAgBA,IAAI,MAAM,GAAG,CAAC,KAAK,KAAK;AACxB,GAAG;AACH,GAAG;AACH,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,WAAW,EAAE;;AAEzC,SAAS,kBAAkB,CAAC,MAAM,EAAE;AACpC,EAAE,IAAI,mBAAmB;AACzB,EAAE,MAAM,WAAW,GAAG,MAAM,CAAC,MAAM,CAAC;AACpC,EAAE,GAAG,WAAW,KAAK,QAAQ,EAAE;AAC/B,IAAI,MAAM,KAAK,GAAG,MAAM,CAAC,WAAW,EAAE;AACtC,IAAI,GAAG,KAAK,KAAK,QAAQ,EAAE,EAAE,mBAAmB,GAAG,EAAE,CAAC;AACtD,SAAS,GAAG,KAAK,KAAK,OAAO,EAAE,EAAE,mBAAmB,GAAG,EAAE,CAAC;AAC1D;AACA,QAAQ;AACR,IAAI,GAAG,WAAW,KAAK,QAAQ,EAAE,EAAE,mBAAmB,GAAG,EAAE,CAAC;AAC5D,SAAS,GAAG,WAAW,KAAK,OAAO,EAAE,EAAE,mBAAmB,GAAG,EAAE,CAAC;AAChE;AACA,EAAE,OAAO;AACT;;AAuEA,IAAI,WAAW,GAAG,CAAC,OAAO,KAAK;AAC/B,EAAE,IAAI,WAAW;AACjB,EAAE,MAAM,YAAY,GAAG,MAAM,CAAC,OAAO,CAAC;AACtC,EAAE,GAAG,YAAY,KAAK,OAAO,EAAE,EAAE,WAAW,GAAG,IAAI,CAAC;AACpD,OAAO;AACP,IAAI,YAAY,KAAK,QAAQ;AAC7B,IAAI,MAAM,CAAC,SAAS,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,OAAO,CAAC,MAAM,IAAI;AAC1D,IAAI;AACJ,IAAI,iBAAiB;AACrB,IAAI,IAAI,MAAM,UAAU,IAAI,MAAM,CAAC,IAAI;AACvC,MAAM,MAAM,CAAC,yBAAyB,CAAC,OAAO;AAC9C,KAAK,EAAE;AACP,MAAM,GAAG,UAAU,KAAK,QAAQ,EAAE,EAAE,SAAS,iBAAiB;AAC9D,MAAM,WAAW,GAAG,CAAC,KAAK,CAAC,UAAU,CAAC;AACtC,MAAM,GAAG,CAAC,WAAW,EAAE,EAAE,MAAM,iBAAiB;AAChD;AACA;AACA,OAAO,EAAE,WAAW,GAAG,KAAK,CAAC;AAC7B,EAAE,OAAO;AACT,CAAC;;AA8GD,IAAI,QAAQ,GAAG;AACf,EAAE,KAAK,EAAE,CAAC;AACV,EAAE,IAAI,EAAE,IAAI;AACZ,EAAE,SAAS,EAAE,EAAE;AACf,CAAC;;AAED,IAAI,SAAS,GAAG;AAChB,EAAE,SAAS,EAAE,GAAG;AAChB,EAAE,MAAM,EAAE,KAAK;AACf,EAAE,QAAQ,EAAE,EAAE;AACd,EAAE,aAAa,EAAE,IAAI;AACrB,EAAE,IAAI,EAAE,KAAK;AACb,EAAE,MAAM,EAAE,KAAK;AACf,EAAE,IAAI,EAAE,KAAK;AACb,CAAC;;AAED,SAAS,wBAAwB,CAAC,WAAW,EAAE,YAAY,EAAE,QAAQ,EAAE;AACvE,EAAE,MAAM,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,QAAQ,EAAE,SAAS,EAAE,QAAQ,EAAE;AACnE,IAAI,SAAS,EAAE,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,QAAQ,CAAC,SAAS;AACnD,GAAG,CAAC;AACJ,EAAE,MAAM,kBAAkB,GAAG,MAAM,CAAC,wBAAwB,CAAC,WAAW,EAAE,YAAY,CAAC;AACvF,EAAE,GAAG,CAAC,OAAO,CAAC,aAAa,IAAI,CAAC,kBAAkB,CAAC,UAAU,EAAE,EAAE,MAAM;AACvE,EAAE,GAAG,CAAC,OAAO,CAAC,SAAS,CAAC,QAAQ,CAAC,WAAW,CAAC,EAAE,EAAE,OAAO,CAAC,SAAS,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;AACxF,EAAE,GAAG,OAAO,CAAC,SAAS,CAAC,QAAQ,CAAC,kBAAkB,CAAC,KAAK,CAAC,EAAE,EAAE,MAAM;AACnE,EAAE,GAAG,OAAO,CAAC,IAAI,EAAE;AACnB,IAAI,OAAO,CAAC,IAAI,GAAG,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,QAAQ,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,YAAY,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,GAAG,YAAY;AAC5H,IAAI,kBAAkB,CAAC,IAAI,GAAG,OAAO,CAAC,IAAI;AAC1C;AACA,EAAE,GAAG,OAAO,CAAC,IAAI,EAAE,EAAE,kBAAkB,CAAC,IAAI,GAAG,MAAM,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC;AAChF,EAAE,GAAG,OAAO,CAAC,MAAM,EAAE,EAAE,kBAAkB,CAAC,MAAM,GAAG,MAAM,CAAC,QAAQ,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC;AAC7F,EAAE,GAAG,OAAO,CAAC,MAAM,EAAE,EAAE,kBAAkB,CAAC,MAAM,GAAG,MAAM,CAAC,QAAQ,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC;AAC7F,EAAE,GAAG,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC,EAAE;AACrE,IAAI,kBAAkB,CAAC,KAAK,GAAG,yBAAyB,CAAC,kBAAkB,CAAC,KAAK,EAAE,OAAO,CAAC;AAC3F;AACA,EAAE,OAAO;AACT;;AAEA,SAAS,yBAAyB,CAAC,WAAW,EAAE,QAAQ,EAAE;AAC1D,EAAE,MAAM,mBAAmB,GAAG,EAAE;AAChC,EAAE,MAAM,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,QAAQ,EAAE,SAAS,EAAE,QAAQ,CAAC;AAClE,EAAE,GAAG,OAAO,CAAC,KAAK,IAAI,OAAO,CAAC,QAAQ,EAAE,EAAE,OAAO,mBAAmB;AACpE,OAAO,EAAE,OAAO,CAAC,KAAK,EAAE,CAAC;AACzB,EAAE,IAAI,MAAM,CAAC,YAAY,EAAE,mBAAmB,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,yBAAyB,CAAC,WAAW,CAAC,CAAC,EAAE;AAClH,IAAI,MAAM,kBAAkB,GAAG,wBAAwB,CAAC,WAAW,EAAE,YAAY,EAAE,OAAO,CAAC;AAC3F,IAAI,GAAG,kBAAkB,KAAK,SAAS,EAAE,EAAE,mBAAmB,CAAC,YAAY,CAAC,GAAG,kBAAkB,CAAC;AAClG;AACA,EAAE,OAAO;AACT;;AAEA,IAAIA,SAAO,GAAG;AACd,EAAE,YAAY,EAAE,KAAK;AACrB,CAAC;;AAED,SAAS,cAAc,CAAC,OAAO,EAAE,YAAY,EAAE,mBAAmB,EAAE,QAAQ,EAAE;AAC9E,EAAE,MAAM,kBAAkB,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,mBAAmB,CAAC;AACnE,EAAE,MAAM,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAEA,SAAO,EAAE,QAAQ,CAAC;AACtD,EAAE,MAAM,mBAAmB,GAAG,MAAM,CAAC,kBAAkB,CAAC,KAAK,CAAC;AAC9D,EAAE,GAAG,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC,QAAQ,CAAC,mBAAmB,CAAC,EAAE;AACxD,IAAI,MAAM,aAAa,GAAG,WAAW,CAAC,MAAM,CAAC,gBAAgB;AAC7D,MAAM,kBAAkB,CAAC,mBAAmB,CAAC,EAAE,kBAAkB,CAAC;AAClE,KAAK,CAAC,GAAG,EAAE,GAAG,EAAE;AAChB,IAAI,kBAAkB,CAAC,KAAK,GAAG,gBAAgB,CAAC,aAAa,EAAE,kBAAkB,CAAC,KAAK,EAAE,OAAO,CAAC;AACjG;AACA,OAAO;AACP,IAAI,OAAO,CAAC,YAAY;AACxB,IAAI,MAAM,CAAC,wBAAwB,CAAC,kBAAkB,EAAE,MAAM,CAAC,KAAK,SAAS;AAC7E,IAAI,CAAC,CAAC,WAAW,EAAE,MAAM,CAAC,CAAC,QAAQ,CAAC,mBAAmB;AACvD,IAAI;AACJ,IAAI,kBAAkB,CAAC,KAAK,GAAG,UAAU,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC,kBAAkB,CAAC,KAAK,CAAC;AAC5F;AACA,EAAE,MAAM,CAAC,cAAc,CAAC,OAAO,EAAE,YAAY,EAAE,kBAAkB,CAAC;AAClE,EAAE,GAAG,mBAAmB,CAAC,MAAM,EAAE,EAAE,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC,CAAC;AACtE,EAAE,GAAG,mBAAmB,CAAC,MAAM,EAAE,EAAE,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC,CAAC;AACxE,EAAE,OAAO;AACT;;AAEA,SAAS,gBAAgB,CAAC,OAAO,EAAE,oBAAoB,EAAE,QAAQ,EAAE;AACnE,EAAE,MAAM,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAEA,SAAO,EAAE,QAAQ,CAAC;AACtD,EAAE,IAAI,MAAM;AACZ,IAAI,YAAY,EAAE;AAClB,GAAG,IAAI,MAAM,CAAC,OAAO,CAAC,oBAAoB,CAAC,EAAE;AAC7C,IAAI,cAAc,CAAC,OAAO,EAAE,YAAY,EAAE,mBAAmB,EAAE,OAAO,CAAC;AACvE;AACA,EAAE,OAAO;AACT;;ACpVA,cAAe,CAAC,QAAQ,KAAK,MAAM,CAAC,MAAM,CAAC;AAC3C,EAAE,QAAQ,EAAE,EAAE;AACd,EAAE,SAAS,EAAE,GAAG;AAChB,EAAE,MAAM,EAAE,KAAK;AACf,EAAE,QAAQ,EAAE,EAAE;AACd,EAAE,aAAa,EAAE,IAAI;AACrB,EAAE,IAAI,EAAE,KAAK;AACb,EAAE,MAAM,EAAE,KAAK;AACf,EAAE,IAAI,EAAE,KAAK;AACb,CAAC,EAAE,QAAQ;;ACLI,MAAM,iBAAiB,SAAS,WAAW,CAAC;AAC3D,EAAE;AACF,EAAE,GAAG,GAAG;AACR,EAAE;AACF,EAAE,WAAW,CAAC,KAAK,EAAE,QAAQ,EAAE;AAC/B,IAAI,KAAK;AACT,IAAI,GAAG,CAAC,KAAK,EAAE;AACf,IAAI,IAAI,CAAC,KAAK,GAAG;AACjB,IAAI,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC,QAAQ;AACpC;AACA,EAAE,IAAI,IAAI,GAAG,EAAE,OAAO,IAAI,CAAC,KAAK;AAChC,EAAE,GAAG,GAAG;AACR,IAAI,IAAI,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI;AAC1C,IAAI,GAAG,KAAK,EAAE;AACd,MAAM,MAAM,cAAc,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK;AAC7C,MAAM,MAAM,uBAAuB,GAAG,kBAAkB,CAAC,cAAc;AACvE,MAAM,KAAK,GAAG,gBAAgB,CAAC,uBAAuB,EAAE,cAAc,EAAE,IAAI,CAAC,QAAQ;AACrF;AACA,IAAI,OAAO;AACX;AACA,EAAE,GAAG,CAAC,KAAK,EAAE,EAAE,OAAO,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,SAAS;AAChE,IAAI,yBAAyB,CAAC,KAAK,EAAE;AACrC,MAAM,IAAI,EAAE,IAAI;AAChB,MAAM,IAAI,EAAE,IAAI;AAChB,KAAK;AACL,GAAG,CAAC;AACJ,EAAE,MAAM,GAAG,EAAE,OAAO,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC;AAClD;;AC9Be,MAAM,kBAAkB,SAAS,WAAW,CAAC;AAC5D,EAAE,QAAQ,GAAG;AACb,EAAE,OAAO,GAAG;AACZ,EAAE,WAAW,CAAC,OAAO,GAAG,EAAE,EAAE,QAAQ,EAAE;AACtC,IAAI,KAAK;AACT,IAAI,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,EAAE,QAAQ;AACzC,IAAI,IAAI,CAAC,SAAS,CAAC,OAAO;AAC1B;AACA,EAAE,SAAS,CAAC,OAAO,EAAE,QAAQ,EAAE;AAC/B,IAAI,IAAI,MAAM,CAAC,UAAU,EAAE,aAAa,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE;AACtE,MAAM,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,GAAG,IAAIC,iBAAK,CAAC,UAAU,EAAE,aAAa;AACpE;AACA;AACA,EAAE,YAAY,CAAC,OAAO,EAAE;AACxB,IAAI,IAAI,MAAM,UAAU,IAAI,OAAO,EAAE;AACrC,MAAM,OAAO,IAAI,CAAC,OAAO,CAAC,UAAU;AACpC;AACA;AACA,EAAE,SAAS,CAAC,MAAM,EAAE;AACpB,IAAI,GAAG,CAAC,MAAM,EAAE,EAAE,OAAO,IAAI,CAAC,OAAO;AACrC,IAAI,MAAM,MAAM,GAAG;AACnB,IAAI,IAAI,MAAM,KAAK,IAAI,EAAE,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE;AAC1C,MAAM,MAAM,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK;AACxC;AACA,IAAI,OAAO;AACX;AACA,EAAE,KAAK,GAAG,EAAE,YAAY,CAAC,KAAK,GAAE;AAChC;;;;","x_google_ignoreList":[0]}