const e={string:String,number:Number,boolean:Boolean,bigint:BigInt,undefined:void 0,null:null},t=(Object.keys(e),Object.values(e),{object:Object,array:Array}),s=(Object.keys(t),Object.values(t),Object.assign({},e,t));Object.keys(s),Object.values(s),e.String,e.Number,e.Boolean;var r=e=>Object.prototype.toString.call(e).slice(8,-1).toLowerCase();function n(e){let t;const s=r(e);if("string"===s){const s=e.toLowerCase();"object"===s?t={}:"array"===s&&(t=[])}else"object"===s?t={}:"array"===s&&(t=[]);return t}var o={depth:0,path:null,ancestors:[]},a={delimiter:".",frozen:!1,maxDepth:10,nonenumerable:!0,path:!1,sealed:!1,type:!1};function c(e,t,s){const n=Object.assign({},o,a,s,{ancestors:Object.assign([],s.ancestors)}),c=Object.getOwnPropertyDescriptor(e,t);if((n.nonenumerable||c.enumerable)&&(n.ancestors.includes(e)||n.ancestors.unshift(e),!n.ancestors.includes(c.value)))return n.path&&(n.path="string"===r(n.path)?[n.path,t].join(n.delimiter):t,c.path=n.path),n.type&&(c.type=r(c.value)),n.frozen&&(c.frozen=Object.isFrozen(c.value)),n.sealed&&(c.sealed=Object.isSealed(c.value)),["array","object"].includes(r(c.value))&&(c.value=i(c.value,n)),c}function i(e,t){const s={},r=Object.assign({},o,a,t);if(r.depth>=r.maxDepth)return s;r.depth++;for(const[t,n]of Object.entries(Object.getOwnPropertyDescriptors(e))){const n=c(e,t,r);void 0!==n&&(s[t]=n)}return s}var l={configurable:!1,enumerable:!1,frozen:!1,sealed:!1,typeCoercion:!1,writable:!1};function u(t,s,o,a){const c=Object.assign({},o),i=Object.assign({},l,a),u=r(c.value);if(["array","object"].includes(u)){const e=(e=>{let t;const s=r(e);if("array"===s)t=!0;else if("object"===s&&Number.isInteger(e.length)&&e.length>=0){e:for(const s of Object.keys(Object.getOwnPropertyDescriptors(e)))if("length"!==s&&(t=!isNaN(s),!t))break e}else t=!1;return t})(Object.defineProperties(n(u),c.value))?[]:{};c.value=b(e,c.value,i)}else i.typeCoercion&&void 0!==Object.getOwnPropertyDescriptor(c,"type")&&!["undefined","null"].includes(u)&&(c.value=e[c.type](c.value));return Object.defineProperty(t,s,c),o.sealed&&Object.seal(t[s]),o.frozen&&Object.freeze(t[s]),t}function b(e,t,s){const r=Object.assign({},l,s);for(const[s,n]of Object.entries(t))u(e,s,n,r);return e}class p extends EventTarget{#e;#t=localStorage;#s;constructor(e,t){super(),e&&(this.#s=e,this.#e=(e=>Object.assign({basename:"",delimiter:".",frozen:!1,maxDepth:10,nonenumerable:!0,path:!1,sealed:!1,type:!1},e))(t))}get path(){return this.#s}get(){let e=this.#t.getItem(this.path);if(e){const t=JSON.parse(e);e=b(n(t),t,this.#e)}return e}set(e){return this.#t.setItem(this.path,JSON.stringify(i(e,{path:!0,type:!0})))}remove(){return this.#t.removeItem(this.path)}}class h extends EventTarget{#e={};#r={};constructor(e={},t){super(),Object.assign(this.#e,t),this.addRoutes(e)}addRoutes(e,t){for(const[t,s]of Object.entries(e))this.#r[t]=new p(t,s)}removeRoutes(e){for(const t of e)delete this.#r[t]}getRoutes(e){if(!e)return this.#r;const t={};for(const s of[].concat(e))t[s]=this.#r[s];return t}clear(){localStorage.clear()}}export{p as Route,h as Router};
//# sourceMappingURL=atilax.min.js.map
