{"version":3,"file":"atilax.min.js","sources":["../../Recourse/distributement/recourse.js","../development/route/options.js","../development/route/index.js","../development/router/index.js"],"sourcesContent":["const Primitives = {\n  'string': String, \n  'number': Number, \n  'boolean': Boolean, \n  'bigint': BigInt,\n  'undefined': undefined,\n  'null': null,\n};\nconst PrimitiveKeys = Object.keys(Primitives);\nconst PrimitiveValues = Object.values(Primitives);\nconst Objects = {\n  'object': Object,\n  'array': Array,\n};\nconst ObjectKeys = Object.keys(Objects);\nconst ObjectValues = Object.values(Objects);\nconst Types = Object.assign({}, Primitives, Objects);\nconst TypeKeys = Object.keys(Types);\nconst TypeValues = Object.values(Types);\nconst TypeMethods = [\n Primitives.String, Primitives.Number, Primitives.Boolean, \n Objects.Object, Objects.Array\n];\n\nvar index = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ObjectKeys: ObjectKeys,\n  ObjectValues: ObjectValues,\n  Objects: Objects,\n  PrimitiveKeys: PrimitiveKeys,\n  PrimitiveValues: PrimitiveValues,\n  Primitives: Primitives,\n  TypeKeys: TypeKeys,\n  TypeMethods: TypeMethods,\n  TypeValues: TypeValues,\n  Types: Types\n});\n\nvar typeOf = ($data) => Object\n  .prototype\n  .toString\n  .call($data).slice(8, -1).toLowerCase();\n\nfunction typedObjectLiteral($value) {\n  let _typedObjectLiteral;\n  const typeOfValue = typeOf($value);\n  if(typeOfValue === 'string') {\n    const value = $value.toLowerCase();\n    if(value === 'object') { _typedObjectLiteral = {}; }\n    else if(value === 'array') { _typedObjectLiteral = []; }\n  }\n  else  {\n    if(typeOfValue === 'object') { _typedObjectLiteral = {}; }\n    else if(typeOfValue === 'array') { _typedObjectLiteral = []; }\n  }\n  return _typedObjectLiteral\n}\n\nvar regularExpressions = {\n  quotationEscape: /\\.(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/,\n};\n\nfunction get($path, $source) {\n  const subpaths = $path.split(new RegExp(regularExpressions.quotationEscape));\n  const key = subpaths.pop();\n  let subtarget = $source;\n  for(const $subpath of subpaths) { subtarget = subtarget[$subpath]; }\n  return subtarget[key]\n}\nfunction set($path, $source) {\n  const subpaths = $path.split(new RegExp(regularExpressions.quotationEscape));\n  const key = subpaths.pop();\n  const target = (key && !isNaN(key)) ? [] : {};\n  let subtarget = target;\n  let subpathIndex = 0;\n  while(subpathIndex < subpaths.length - 2) {\n    const $subpath = keypaths[subpathIndex];\n    if(isNaN($subpath)) { subtarget[$subpath] = {}; }\n    else { subtarget[$subpath] = {}; }\n    subtarget = subtarget[$subpath];\n    subpathIndex++;\n  }\n  subtarget[key] = $source;\n  return target\n}\n\nconst ValidPropertyTypes = ['string', 'function'];\nfunction expandTree($source, $property) {\n  const typeOfProperty = typeOf($property);\n  const typeOfSource = typeOf($source);\n  if(\n    !ValidPropertyTypes.includes(typeOfProperty) ||\n    !ObjectKeys.includes(typeOfSource)\n  ) { return $source }\n  let target = typedObjectLiteral($source);\n  for(const [$sourceKey, $sourceValue] of Object.entries($source)) {\n    const sourceValue = (\n      ObjectKeys.includes(typeOf($sourceValue))\n    ) ? expandTree($sourceValue, $property) : $sourceValue;\n    if(typeOfProperty === ValidPropertyTypes[0]) {\n      target[$sourceKey] = set($property, sourceValue);\n    }\n    else if(typeOfProperty === ValidPropertyTypes[1]) {\n      target[$sourceKey] = $property(sourceValue);\n    }\n  }\n  return target\n}\n\nfunction impandTree($source, $property) {\n  const typeOfProperty = typeOf($property);\n  const typeOfSource = typeOf($source);\n  if(\n    !['string', 'function'].includes(typeOfProperty) ||\n    !['array', 'object'].includes(typeOfSource)\n  ) { return $source }\n  let target = typedObjectLiteral($source);\n  for(const [$sourceKey, $sourceValue] of Object.entries($source)) {\n    if(typeOfProperty === 'string') { target[$sourceKey] = get($property, $sourceValue); }\n    else if(typeOfProperty === 'function') { target[$sourceKey] = $property($sourceValue); }\n    if(target[$sourceKey] && typeof target[$sourceKey] === 'object') {\n      target[$sourceKey] = impandTree(target[$sourceKey], $property);\n    }\n  }\n  return target\n}\n\nvar isArrayLike = ($source) => {\n  let isArrayLike;\n  const typeOfSource = typeOf($source);\n  if(typeOfSource === 'array') { isArrayLike = true; }\n  else if(\n    typeOfSource === 'object' &&\n    Number.isInteger($source.length) && $source.length >= 0\n  ) {\n    iterateSourceKeys: \n    for(const $sourceKey of Object.keys(\n      Object.getOwnPropertyDescriptors($source)\n    )) {\n      if($sourceKey === 'length') { continue iterateSourceKeys }\n      isArrayLike = !isNaN($sourceKey);\n      if(!isArrayLike) { break iterateSourceKeys }\n    }\n  }\n  else { isArrayLike = false; }\n  return isArrayLike\n};\n\nconst defaultAccessor = ($target, $property) => {\n  if($property === undefined) { return $target }\n  else { return $target[$property] }\n};\nvar Accessors = {\n  default: defaultAccessor};\n\nconst Options$2 = {\n  depth: 0,\n  maxDepth: 10,\n  accessors: [Accessors.default],\n  ancestors: [],\n};\nfunction propertyDirectory($object, $options) {\n  const _propertyDirectory = [];\n  const options = Object.assign({}, Options$2, $options, {\n    ancestors: [].concat($options.ancestors)\n  });\n  options.depth++;\n  if(options.depth > options.maxDepth) { return _propertyDirectory }\n  iterateAccessors: \n  for(const $accessor of options.accessors) {\n    const accessor = $accessor.bind($object);\n    const object = accessor($object);\n    if(!object) { continue iterateAccessors }\n    if(!options.ancestors.includes(object)) { options.ancestors.unshift(object); }\n    for(const [$key, $value] of Object.entries(object)) {\n      if(!options.values) { _propertyDirectory.push($key); }\n      else if(options.values) { _propertyDirectory.push([$key, $value]); }\n      if(\n        typeof $value === 'object' &&\n        $value !== null &&\n        !Object.is($value, object) && \n        !options.ancestors.includes($value)\n      ) {\n        const subtargets = propertyDirectory($value, options);\n        if(!options.values) {\n          for(const $subtarget of subtargets) {\n            const path = [$key, $subtarget].join('.');\n            _propertyDirectory.push(path);\n          }\n        }\n        else if(options.values) {\n          for(const [$subtargetKey, $subtarget] of subtargets) {\n            const path = [$key, $subtargetKey].join('.');\n            _propertyDirectory.push([path, $subtarget]);\n          }\n        }\n      }\n    }\n  }\n  return _propertyDirectory\n}\n\nfunction assign($target, ...$sources) {\n  if(!$target) { return $target}\n  iterateSources: \n  for(const $source of $sources) {\n    if(!$source) continue iterateSources\n    for(const [\n      $sourcePropertyKey, $sourcePropertyValue\n    ] of Object.entries($source)) {\n      const typeOfTargetPropertyValue = typeOf($target[$sourcePropertyKey]);\n      const typeOfSourcePropertyValue = typeOf($sourcePropertyValue);\n      if(\n        typeOfTargetPropertyValue === 'object' &&\n        typeOfSourcePropertyValue === 'object'\n      ) {\n        $target[$sourcePropertyKey] = assign($target[$sourcePropertyKey], $sourcePropertyValue);\n      }\n      else {\n        $target[$sourcePropertyKey] = $sourcePropertyValue;\n      }\n    }\n  }\n  return $target\n}\n\nfunction assignConcat($target, ...$sources) {\n  if(!$target) { return $target}\n  iterateSources: \n  for(const $source of $sources) {\n    if(!$source) continue iterateSources\n    for(const [\n      $sourcePropertyKey, $sourcePropertyValue\n    ] of Object.entries($source)) {\n      const typeOfTargetPropertyValue = typeOf($target[$sourcePropertyKey]);\n      const typeOfSourcePropertyValue = typeOf($sourcePropertyValue);\n      if( \n        typeOfTargetPropertyValue === 'object' &&\n        typeOfSourcePropertyValue === 'object'\n      ) {\n        $target[$sourcePropertyKey] = assignConcat($target[$sourcePropertyKey], $sourcePropertyValue);\n      }\n      else if(\n        typeOfTargetPropertyValue === 'array' &&\n        typeOfSourcePropertyValue === 'array'\n      ) {\n        $target[$sourcePropertyKey] = $target[$sourcePropertyKey].concat($sourcePropertyValue);\n      }\n      else {\n        $target[$sourcePropertyKey] = $sourcePropertyValue;\n      }\n    }\n  }\n  return $target\n}\n\nvar Options$1 = {\n  ancestors: [],\n  delimiter: '.',\n  depth: 0,\n  frozen: false,\n  maxDepth: 10,\n  nonenumerable: true,\n  path: false,\n  sealed: false,\n  type: false,\n};\n\nfunction getOwnPropertyDescriptor($properties, $propertyKey, $options) {\n  const options = Object.assign({}, Options$1, $options, {\n    ancestors: Object.assign([], $options.ancestors)\n  });\n  const propertyDescriptor = Object.getOwnPropertyDescriptor($properties, $propertyKey);\n  if(!options.nonenumerable && !propertyDescriptor.enumerable) { return }\n  if(!options.ancestors.includes($properties)) { options.ancestors.unshift($properties); }\n  if(options.ancestors.includes(propertyDescriptor.value)) { return }\n  if(options.path) {\n    options.path = (typeOf(options.path) === 'string') ? [options.path, $propertyKey].join(options.delimiter) : $propertyKey;\n    propertyDescriptor.path = options.path;\n  }\n  if(options.type) { propertyDescriptor.type = typeOf(propertyDescriptor.value); }\n  if(options.frozen) { propertyDescriptor.frozen = Object.isFrozen(propertyDescriptor.value); }\n  if(options.sealed) { propertyDescriptor.sealed = Object.isSealed(propertyDescriptor.value); }\n  if(['array', 'object'].includes(typeOf(propertyDescriptor.value))) {\n    propertyDescriptor.value = getOwnPropertyDescriptors(propertyDescriptor.value, options);\n  }\n  return propertyDescriptor\n}\n\nfunction getOwnPropertyDescriptors($properties, $options) {\n  const propertyDescriptors = {};\n  const options = Object.assign({}, Options$1, $options);\n  if(options.depth >= options.maxDepth) { return propertyDescriptors }\n  else { options.depth++; }\n  for(const [$propertyKey, $propertyDescriptor] of Object.entries(Object.getOwnPropertyDescriptors($properties))) {\n    const propertyDescriptor = getOwnPropertyDescriptor($properties, $propertyKey, options);\n    if(propertyDescriptor !== undefined) { propertyDescriptors[$propertyKey] = propertyDescriptor; }\n  }\n  return propertyDescriptors\n}\n\nvar Options = {\n  typeCoercion: false,\n};\n\nfunction defineProperty($target, $propertyKey, $propertyDescriptor, $options) {\n  const propertyDescriptor = Object.assign({}, $propertyDescriptor);\n  const options = Object.assign({}, Options, $options);\n  const typeOfPropertyValue = typeOf(propertyDescriptor.value);\n  if(['array', 'object'].includes(typeOfPropertyValue)) {\n    const propertyValue = isArrayLike(Object.defineProperties(\n      typedObjectLiteral(typeOfPropertyValue), propertyDescriptor.value\n    )) ? [] : {};\n    propertyDescriptor.value = defineProperties(propertyValue, propertyDescriptor.value, options);\n  }\n  else if(\n    options.typeCoercion && \n    Object.getOwnPropertyDescriptor(propertyDescriptor, 'type') !== undefined &&\n    !['undefined', 'null'].includes(typeOfPropertyValue)\n  ) {\n    propertyDescriptor.value = Primitives[propertyDescriptor.type](propertyDescriptor.value);\n  }\n  Object.defineProperty($target, $propertyKey, propertyDescriptor);\n  if($propertyDescriptor.sealed) { Object.seal($target[$propertyKey]); }\n  if($propertyDescriptor.frozen) { Object.freeze($target[$propertyKey]); }\n  return $target\n}\n\nfunction defineProperties($target, $propertyDescriptors, $options) {\n  const options = Object.assign({}, Options, $options);\n  for(const [\n    $propertyKey, $propertyDescriptor\n  ] of Object.entries($propertyDescriptors)) {\n    defineProperty($target, $propertyKey, $propertyDescriptor, options);\n  }\n  return $target\n}\n\nfunction freeze($target) {\n  for(const [$propertyKey, $propertyValue] of Object.entries($target)) {\n    if(Object.is($propertyValue, $target)) { continue }\n    if($propertyValue && typeof $propertyValue === 'object') {\n      freeze($propertyValue);\n    }\n  }\n  return Object.freeze($target)\n}\n\nexport { assign, assignConcat, defineProperties, defineProperty, expandTree, freeze, getOwnPropertyDescriptor, getOwnPropertyDescriptors, impandTree, isArrayLike, propertyDirectory, regularExpressions, typeOf, typedObjectLiteral, index as variables };\n//# sourceMappingURL=recourse.js.map\n","import { assign, typeOf } from 'recourse'\nexport default ($options) => {\n  const options = assign({\n    propertyDescriptors: false,\n    defineProperties: false,\n    replacers: [],\n    revivers: [],\n  }, $options)\n  if(options.propertyDescriptors?.type) {\n    options.replacers.push(function BigintReplacer($key, $value) {\n      if(typeOf($value) === 'bigint') { return String($value) }\n      else { return $value }\n    })\n  }\n  return options\n}","import {\n  defineProperties, getOwnPropertyDescriptors, typedObjectLiteral,\n} from 'recourse'\nimport Options from './options.js'\nfunction JSONMiddlewares($middlewares, $key, $value) {\n  let value = $value\n  for(const $middleware of $middlewares) {\n    value = $middleware($key, $value)\n  }\n  return value\n}\nexport default class LocalStorageRoute extends EventTarget {\n  constructor($path, $options) {\n    super()\n    if(!$path) return null\n    const options = Options($options)\n    const db = localStorage\n    Object.defineProperties(this, {\n      'path': { value: $path },\n      'raw': { value: function raw() { return db.getItem(this.path) } },\n      'get': { value: function get() {\n        const { path } = this\n        const raw = db.getItem(this.path)\n        if(['undefined', undefined].includes(raw)) { return }\n        const propertyDescriptors = JSON.parse(raw, JSONMiddlewares.bind(null, options.revivers))\n        const dataTypedObjectLiteral = typedObjectLiteral(propertyDescriptors)\n        const data = (options.propertyDescriptors) ? defineProperties(\n          dataTypedObjectLiteral, propertyDescriptors, options.defineProperties\n        ) : propertyDescriptors\n        this.dispatchEvent(new CustomEvent('get', { detail: { path, raw, data } }))\n        return data\n      } },\n      'set': { value: function set($data) {\n        const data = $data\n        const { path } = this\n        let raw = (options.propertyDescriptors) ? JSON.stringify(\n          getOwnPropertyDescriptors(data, options.propertyDescriptors), JSONMiddlewares.bind(null, options.replacers)\n        ) : JSON.stringify(\n          data, JSONMiddlewares.bind(null, options.replacers)\n        )\n        db.setItem(this.path, raw)\n        this.dispatchEvent(new CustomEvent('set', { detail: { path, raw, data } }))\n        return \n      } },\n      'remove': { value: function remove() {\n        const { path } = this\n        const raw = this.raw()\n        const data = this.get()\n        db.removeItem(this.path)\n        this.dispatchEvent(new CustomEvent('remove', { detail: { path, raw, data } }))\n        return\n      } },\n    })\n  }\n}","import Route from '../route/index.js'\nconst Options = {}\nexport default class LocalStorageRouter extends EventTarget {\n  constructor($routes = {}, $options) {\n    super()\n    const options = Object.assign({}, Options, $options)\n    const routes = {}\n    const db = localStorage\n    Object.defineProperties(this, {\n      'addRoute': { value: function addRoute($routePath, $routeOptions) {\n        routes[$routePath] = new Route($routePath, $routeOptions)\n      } },\n      'addRoutes': { value: function addRoutes($routes, $options) {\n        for(const [$routePath, $routeOptions] of Object.entries($routes)) {\n          this.addRoute($routePath, $routeOptions)\n        }\n      } },\n      'removeRoute': { value: function removeRoute($routePath) {\n        delete routes[$routePath]\n      } }, \n      'removeRoutes': { value: function removeRoutes($routes) {\n        for(const $routePath of $routes) {\n          this.removeRoute($routePath)\n        }\n      } },\n      'getRoute': { value: function getRoute($path) {\n        return routes[$path]\n      } },\n      'getRoutes': { value: function getRoutes($paths) {\n        if(!$paths) { return routes }\n        const getRoutes = {}\n        for(const $path of [].concat($paths)) {\n          getRoutes[$path] = this.getRoute($path)\n        }\n        return getRoutes\n      } },\n      'clear': { value: function clear() { db.clear() } },\n    })\n    this.addRoutes($routes)\n  }\n}"],"names":["Primitives","string","String","number","Number","boolean","Boolean","bigint","BigInt","undefined","null","Objects","Object","keys","values","object","array","Array","Types","assign","typeOf","$data","prototype","toString","call","slice","toLowerCase","typedObjectLiteral","$value","_typedObjectLiteral","typeOfValue","value","$target","$sources","$source","$sourcePropertyKey","$sourcePropertyValue","entries","typeOfTargetPropertyValue","typeOfSourcePropertyValue","Options$1","ancestors","delimiter","depth","frozen","maxDepth","nonenumerable","path","sealed","type","getOwnPropertyDescriptor","$properties","$propertyKey","$options","options","propertyDescriptor","enumerable","includes","unshift","join","isFrozen","isSealed","getOwnPropertyDescriptors","propertyDescriptors","$propertyDescriptor","Options","typeCoercion","defineProperty","typeOfPropertyValue","propertyValue","isArrayLike","typeOfSource","isInteger","length","iterateSourceKeys","$sourceKey","isNaN","defineProperties","seal","freeze","$propertyDescriptors","replacers","revivers","push","$key","JSONMiddlewares","$middlewares","$middleware","LocalStorageRoute","EventTarget","constructor","$path","super","db","localStorage","this","raw","getItem","get","JSON","parse","bind","dataTypedObjectLiteral","data","dispatchEvent","CustomEvent","detail","set","stringify","setItem","remove","removeItem","LocalStorageRouter","$routes","routes","addRoute","$routePath","$routeOptions","Route","addRoutes","removeRoute","removeRoutes","getRoute","getRoutes","$paths","concat","clear"],"mappings":"AAAA,MAAMA,EAAa,CACjBC,OAAUC,OACVC,OAAUC,OACVC,QAAWC,QACXC,OAAUC,OACVC,eAAaA,EACbC,KAAQ,MAIJC,GAFgBC,OAAOC,KAAKb,GACVY,OAAOE,OAAOd,GACtB,CACde,OAAUH,OACVI,MAASC,QAILC,GAFaN,OAAOC,KAAKF,GACVC,OAAOE,OAAOH,GACrBC,OAAOO,OAAO,CAAA,EAAInB,EAAYW,IAC3BC,OAAOC,KAAKK,GACVN,OAAOE,OAAOI,GAEhClB,EAAWE,OAAQF,EAAWI,OAAQJ,EAAWM,QAIlD,IAcIc,EAAUC,GAAUT,OACrBU,UACAC,SACAC,KAAKH,GAAOI,MAAM,GAAI,GAAGC,cAE5B,SAASC,EAAmBC,GAC1B,IAAIC,EACJ,MAAMC,EAAcV,EAAOQ,GAC3B,GAAmB,WAAhBE,EAA0B,CAC3B,MAAMC,EAAQH,EAAOF,cACR,WAAVK,EAAsBF,EAAsB,CAAA,EAC7B,UAAVE,IAAqBF,EAAsB,GACvD,KAEuB,WAAhBC,EAA4BD,EAAsB,CAAA,EAC7B,UAAhBC,IAA2BD,EAAsB,IAE3D,OAAOA,CACT,CAkJA,SAASV,EAAOa,KAAYC,GAC1B,IAAID,EAAW,OAAOA,EAEtB,IAAI,MAAME,KAAWD,EACnB,GAAIC,EACJ,IAAI,MACFC,EAAoBC,KACjBxB,OAAOyB,QAAQH,GAAU,CAC5B,MAAMI,EAA4BlB,EAAOY,EAAQG,IAC3CI,EAA4BnB,EAAOgB,GAKvCJ,EAAQG,GAHsB,WAA9BG,GAC8B,WAA9BC,EAE8BpB,EAAOa,EAAQG,GAAqBC,GAGpCA,CAEtC,CAEE,OAAOJ,CACT,CAgCA,IAAIQ,EAAY,CACdC,UAAW,GACXC,UAAW,IACXC,MAAO,EACPC,QAAQ,EACRC,SAAU,GACVC,eAAe,EACfC,MAAM,EACNC,QAAQ,EACRC,MAAM,GAGR,SAASC,EAAyBC,EAAaC,EAAcC,GAC3D,MAAMC,EAAU1C,OAAOO,OAAO,CAAA,EAAIqB,EAAWa,EAAU,CACrDZ,UAAW7B,OAAOO,OAAO,GAAIkC,EAASZ,aAElCc,EAAqB3C,OAAOsC,yBAAyBC,EAAaC,GACxE,IAAIE,EAAQR,eAAkBS,EAAmBC,cAC7CF,EAAQb,UAAUgB,SAASN,IAAgBG,EAAQb,UAAUiB,QAAQP,IACtEG,EAAQb,UAAUgB,SAASF,EAAmBxB,QAWjD,OAVGuB,EAAQP,OACTO,EAAQP,KAAiC,WAAzB3B,EAAOkC,EAAQP,MAAsB,CAACO,EAAQP,KAAMK,GAAcO,KAAKL,EAAQZ,WAAaU,EAC5GG,EAAmBR,KAAOO,EAAQP,MAEjCO,EAAQL,OAAQM,EAAmBN,KAAO7B,EAAOmC,EAAmBxB,QACpEuB,EAAQV,SAAUW,EAAmBX,OAAShC,OAAOgD,SAASL,EAAmBxB,QACjFuB,EAAQN,SAAUO,EAAmBP,OAASpC,OAAOiD,SAASN,EAAmBxB,QACjF,CAAC,QAAS,UAAU0B,SAASrC,EAAOmC,EAAmBxB,UACxDwB,EAAmBxB,MAAQ+B,EAA0BP,EAAmBxB,MAAOuB,IAE1EC,CACT,CAEA,SAASO,EAA0BX,EAAaE,GAC9C,MAAMU,EAAsB,CAAE,EACxBT,EAAU1C,OAAOO,OAAO,CAAA,EAAIqB,EAAWa,GAC7C,GAAGC,EAAQX,OAASW,EAAQT,SAAY,OAAOkB,EACxCT,EAAQX,QACf,IAAI,MAAOS,EAAcY,KAAwBpD,OAAOyB,QAAQzB,OAAOkD,0BAA0BX,IAAe,CAC9G,MAAMI,EAAqBL,EAAyBC,EAAaC,EAAcE,QACrD7C,IAAvB8C,IAAoCQ,EAAoBX,GAAgBG,EAC/E,CACE,OAAOQ,CACT,CAEA,IAAIE,EAAU,CACZC,cAAc,GAGhB,SAASC,EAAenC,EAASoB,EAAcY,EAAqBX,GAClE,MAAME,EAAqB3C,OAAOO,OAAO,CAAA,EAAI6C,GACvCV,EAAU1C,OAAOO,OAAO,CAAA,EAAI8C,EAASZ,GACrCe,EAAsBhD,EAAOmC,EAAmBxB,OACtD,GAAG,CAAC,QAAS,UAAU0B,SAASW,GAAsB,CACpD,MAAMC,EAvLQ,CAACnC,IACjB,IAAIoC,EACJ,MAAMC,EAAenD,EAAOc,GAC5B,GAAoB,UAAjBqC,EAA4BD,GAAc,OACxC,GACc,WAAjBC,GACAnE,OAAOoE,UAAUtC,EAAQuC,SAAWvC,EAAQuC,QAAU,GAEtDC,EACA,IAAI,MAAMC,KAAc/D,OAAOC,KAC7BD,OAAOkD,0BAA0B5B,IAEjC,GAAkB,WAAfyC,IACHL,GAAeM,MAAMD,IACjBL,GAAe,MAAMI,OAGtBJ,GAAc,EACrB,OAAOA,GAqKiBA,CAAY1D,OAAOiE,iBACvClD,EAAmByC,GAAsBb,EAAmBxB,QACzD,GAAK,CAAE,EACZwB,EAAmBxB,MAAQ8C,EAAiBR,EAAed,EAAmBxB,MAAOuB,EACzF,MAEIA,EAAQY,mBACwDzD,IAAhEG,OAAOsC,yBAAyBK,EAAoB,UACnD,CAAC,YAAa,QAAQE,SAASW,KAEhCb,EAAmBxB,MAAQ/B,EAAWuD,EAAmBN,MAAMM,EAAmBxB,QAKpF,OAHAnB,OAAOuD,eAAenC,EAASoB,EAAcG,GAC1CS,EAAoBhB,QAAUpC,OAAOkE,KAAK9C,EAAQoB,IAClDY,EAAoBpB,QAAUhC,OAAOmE,OAAO/C,EAAQoB,IAChDpB,CACT,CAEA,SAAS6C,EAAiB7C,EAASgD,EAAsB3B,GACvD,MAAMC,EAAU1C,OAAOO,OAAO,CAAA,EAAI8C,EAASZ,GAC3C,IAAI,MACFD,EAAcY,KACXpD,OAAOyB,QAAQ2C,GAClBb,EAAenC,EAASoB,EAAcY,EAAqBV,GAE7D,OAAOtB,CACT,CC/UA,IAAeQ,EAACa,IACd,MAAMC,EAAUnC,EAAO,CACrB4C,qBAAqB,EACrBc,kBAAkB,EAClBI,UAAW,GACXC,SAAU,IACT7B,GAOH,OANGC,EAAQS,qBAAqBd,MAC9BK,EAAQ2B,UAAUE,MAAK,SAAwBC,EAAMxD,GACnD,MAAsB,WAAnBR,EAAOQ,GAA+B1B,OAAO0B,GAClCA,CACf,IAEI0B,GCVT,SAAS+B,EAAgBC,EAAcF,EAAMxD,GAC3C,IAAIG,EAAQH,EACZ,IAAI,MAAM2D,KAAeD,EACvBvD,EAAQwD,EAAYH,EAAMxD,GAE5B,OAAOG,CACT,CACe,MAAMyD,UAA0BC,YAC7C,WAAAC,CAAYC,EAAOtC,GAEjB,GADAuC,SACID,EAAO,OAAO,KAClB,MAAMrC,EAAUW,EAAQZ,GAClBwC,EAAKC,aACXlF,OAAOiE,iBAAiBkB,KAAM,CAC5BhD,KAAQ,CAAEhB,MAAO4D,GACjBK,IAAO,CAAEjE,MAAO,WAAiB,OAAO8D,EAAGI,QAAQF,KAAKhD,QACxDmD,IAAO,CAAEnE,MAAO,WACd,MAAMgB,KAAEA,GAASgD,KACXC,EAAMH,EAAGI,QAAQF,KAAKhD,MAC5B,GAAG,CAAC,iBAAatC,GAAWgD,SAASuC,GAAQ,OAC7C,MAAMjC,EAAsBoC,KAAKC,MAAMJ,EAAKX,EAAgBgB,KAAK,KAAM/C,EAAQ4B,WACzEoB,EAAyB3E,EAAmBoC,GAC5CwC,EAAQjD,EAA2B,oBAAIuB,EAC3CyB,EAAwBvC,EAAqBT,EAAQuB,kBACnDd,EAEJ,OADAgC,KAAKS,cAAc,IAAIC,YAAY,MAAO,CAAEC,OAAQ,CAAE3D,OAAMiD,MAAKO,WAC1DA,CACf,GACMI,IAAO,CAAE5E,MAAO,SAAaV,GAC3B,MAAMkF,EAAOlF,GACP0B,KAAEA,GAASgD,KACjB,IAAIC,EAAO1C,EAA2B,oBAAI6C,KAAKS,UAC7C9C,EAA0ByC,EAAMjD,EAAQS,qBAAsBsB,EAAgBgB,KAAK,KAAM/C,EAAQ2B,YAC/FkB,KAAKS,UACPL,EAAMlB,EAAgBgB,KAAK,KAAM/C,EAAQ2B,YAE3CY,EAAGgB,QAAQd,KAAKhD,KAAMiD,GACtBD,KAAKS,cAAc,IAAIC,YAAY,MAAO,CAAEC,OAAQ,CAAE3D,OAAMiD,MAAKO,UAEzE,GACMO,OAAU,CAAE/E,MAAO,WACjB,MAAMgB,KAAEA,GAASgD,KACXC,EAAMD,KAAKC,MACXO,EAAOR,KAAKG,MAClBL,EAAGkB,WAAWhB,KAAKhD,MACnBgD,KAAKS,cAAc,IAAIC,YAAY,SAAU,CAAEC,OAAQ,CAAE3D,OAAMiD,MAAKO,UAE5E,IAEA,ECpDA,MAAMtC,EAAU,CAAA,EACD,MAAM+C,UAA2BvB,YAC9C,WAAAC,CAAYuB,EAAU,CAAE,EAAE5D,GACxBuC,QACgBhF,OAAOO,OAAO,CAAE,EAAE8C,EAASZ,GAA3C,MACM6D,EAAS,CAAA,EACTrB,EAAKC,aACXlF,OAAOiE,iBAAiBkB,KAAM,CAC5BoB,SAAY,CAAEpF,MAAO,SAAkBqF,EAAYC,GACjDH,EAAOE,GAAc,IAAIE,EAAMF,EAAYC,EACnD,GACME,UAAa,CAAExF,MAAO,SAAmBkF,EAAS5D,GAChD,IAAI,MAAO+D,EAAYC,KAAkBzG,OAAOyB,QAAQ4E,GACtDlB,KAAKoB,SAASC,EAAYC,EAEpC,GACMG,YAAe,CAAEzF,MAAO,SAAqBqF,UACpCF,EAAOE,EACtB,GACMK,aAAgB,CAAE1F,MAAO,SAAsBkF,GAC7C,IAAI,MAAMG,KAAcH,EACtBlB,KAAKyB,YAAYJ,EAE3B,GACMM,SAAY,CAAE3F,MAAO,SAAkB4D,GACrC,OAAOuB,EAAOvB,EACtB,GACMgC,UAAa,CAAE5F,MAAO,SAAmB6F,GACvC,IAAIA,EAAU,OAAOV,EACrB,MAAMS,EAAY,CAAA,EAClB,IAAI,MAAMhC,IAAS,GAAGkC,OAAOD,GAC3BD,EAAUhC,GAASI,KAAK2B,SAAS/B,GAEnC,OAAOgC,CACf,GACMG,MAAS,CAAE/F,MAAO,WAAmB8D,EAAGiC,YAE1C/B,KAAKwB,UAAUN,EACnB"}